{"ast":null,"code":"/**\n * Anime.js - timer - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { minValue, noop, maxValue, compositionTypes, tickModes } from '../core/consts.js';\nimport { isFnc, isUnd, now, clampInfinity, clamp, round, forEachChildren, addChild, normalizeTime, floor } from '../core/helpers.js';\nimport { globals, scope } from '../core/globals.js';\nimport { setValue } from '../core/values.js';\nimport { tick } from '../core/render.js';\nimport { removeTweenSliblings, composeTween, getTweenSiblings } from '../animation/composition.js';\nimport { Clock } from '../core/clock.js';\nimport { engine } from '../engine/engine.js';\n\n/**\n * @import {\n *   Callback,\n *   TimerParams,\n *   Renderable,\n *   Tween,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   ScrollObserver,\n * } from '../events/scroll.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween */tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n    super(0);\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate\n    } = parameters;\n    if (scope.current) scope.current.register(this);\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay;\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true || timerLoop === Infinity || /** @type {Number} */timerLoop < 0 ? Infinity : /** @type {Number} */timerLoop + 1;\n    let offsetPosition = 0;\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      // Make sure to tick the engine once if not currently running to get up to date engine._elapsedTime\n      // to avoid big gaps with the following offsetPosition calculation\n      if (!engine.reqId) engine.requestTick(now());\n      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit\n      offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n  get cancelled() {\n    return !!this._cancelled;\n  }\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(true).play();\n  }\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n  set iterationCurrentTime(time) {\n    this.currentTime = this.iterationDuration * this._currentIteration + time;\n  }\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress;\n  }\n  get currentIteration() {\n    return this._currentIteration;\n  }\n  set currentIteration(iterationCount) {\n    this.currentTime = this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1);\n  }\n  get reversed() {\n    return !!this._reversed;\n  }\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n  get speed() {\n    return super.speed;\n  }\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Boolean} [softReset]\n   * @return {this}\n   */\n  reset(softReset = false) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, ~~softReset, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Boolean} internalRender\n   * @return {this}\n   */\n  init(internalRender = false) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, ~~internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */autoplay.linked)) {\n      /** @type {ScrollObserver} */autoplay.link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    // TODO: See if we can safely use engine._elapsedTime here\n    // if (!engine.reqId) engine.requestTick(now())\n    // this._startTime = engine._elapsedTime - (this._currentTime + this._delay) * timeScale;\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset().resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek(duration * iterations - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n  /**\n    * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n    * @return {this}\n    */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */this._autoplay;\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n  /**\n    * Imediatly completes the timer, cancels it and triggers the onComplete callback\n    * @return {this}\n    */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedTimer\n   */\n\n  /**\n   * @param  {Callback<ResolvedTimer>} [callback]\n   * @return Promise<this>\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(/** @type {ResolvedTimer} */this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\nexport { Timer, createTimer };","map":{"version":3,"names":["minValue","noop","maxValue","compositionTypes","tickModes","isFnc","isUnd","now","clampInfinity","clamp","round","forEachChildren","addChild","normalizeTime","floor","globals","scope","setValue","tick","removeTweenSliblings","composeTween","getTweenSiblings","Clock","engine","resetTimerProperties","timer","paused","began","completed","reviveTimer","_cancelled","_hasChildren","tween","_composition","none","target","property","timerId","Timer","constructor","parameters","parent","parentPosition","id","delay","duration","reversed","alternate","loop","loopDelay","autoplay","frameRate","playbackRate","onComplete","onLoop","onPause","onBegin","onBeforeUpdate","onUpdate","current","register","timerInitTime","_elapsedTime","timerDefaults","defaults","timerDelay","timerDuration","Infinity","timerLoop","timerLoopDelay","timerIterationCount","offsetPosition","reqId","requestTick","_startTime","timeScale","backwards","iterationDuration","iterationCount","_autoplay","_offset","_delay","_loopDelay","_iterationTime","_currentIteration","_resolve","_running","_reversed","_reverse","_alternate","_prev","_next","_lastTime","_fps","_speed","cancelled","cancel","reset","play","currentTime","_currentTime","precision","time","pause","seek","resume","iterationCurrentTime","progress","iterationProgress","currentIteration","reverse","speed","resetTime","softReset","FORCE","init","internalRender","fps","linked","link","wake","restart","muteCallbacks","isPaused","AUTO","count","iterations","child","stretch","newDuration","currentDuration","normlizedDuration","isSetter","revert","ap","complete","then","callback","onResolve","Promise","r","createTimer"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/timer/timer.js"],"sourcesContent":["/**\n * Anime.js - timer - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { minValue, noop, maxValue, compositionTypes, tickModes } from '../core/consts.js';\nimport { isFnc, isUnd, now, clampInfinity, clamp, round, forEachChildren, addChild, normalizeTime, floor } from '../core/helpers.js';\nimport { globals, scope } from '../core/globals.js';\nimport { setValue } from '../core/values.js';\nimport { tick } from '../core/render.js';\nimport { removeTweenSliblings, composeTween, getTweenSiblings } from '../animation/composition.js';\nimport { Clock } from '../core/clock.js';\nimport { engine } from '../engine/engine.js';\n\n/**\n * @import {\n *   Callback,\n *   TimerParams,\n *   Renderable,\n *   Tween,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   ScrollObserver,\n * } from '../events/scroll.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween */tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\n\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n\n    super(0);\n\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate,\n    } = parameters;\n\n    if (scope.current) scope.current.register(this);\n\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true ||\n                                timerLoop === Infinity ||\n                                /** @type {Number} */(timerLoop) < 0 ? Infinity :\n                                /** @type {Number} */(timerLoop) + 1;\n\n    let offsetPosition = 0;\n\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      // Make sure to tick the engine once if not currently running to get up to date engine._elapsedTime\n      // to avoid big gaps with the following offsetPosition calculation\n      if (!engine.reqId) engine.requestTick(now());\n      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit\n      offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n\n  get cancelled() {\n    return !!this._cancelled;\n  }\n\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(true).play();\n  }\n\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n\n  set iterationCurrentTime(time) {\n    this.currentTime = (this.iterationDuration * this._currentIteration) + time;\n  }\n\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);\n  }\n\n  get currentIteration() {\n    return this._currentIteration;\n  }\n\n  set currentIteration(iterationCount) {\n    this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));\n  }\n\n  get reversed() {\n    return !!this._reversed;\n  }\n\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n\n  get speed() {\n    return super.speed;\n  }\n\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Boolean} [softReset]\n   * @return {this}\n   */\n  reset(softReset = false) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, ~~softReset, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Boolean} internalRender\n   * @return {this}\n   */\n  init(internalRender = false) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, ~~internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {\n      /** @type {ScrollObserver} */(autoplay).link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    // TODO: See if we can safely use engine._elapsedTime here\n    // if (!engine.reqId) engine.requestTick(now())\n    // this._startTime = engine._elapsedTime - (this._currentTime + this._delay) * timeScale;\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset().resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek((duration * iterations) - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */(this._autoplay);\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedTimer\n   */\n\n  /**\n   * @param  {Callback<ResolvedTimer>} [callback]\n   * @return Promise<this>\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(/** @type {ResolvedTimer} */(this));\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n\n}\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\n\nexport { Timer, createTimer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}