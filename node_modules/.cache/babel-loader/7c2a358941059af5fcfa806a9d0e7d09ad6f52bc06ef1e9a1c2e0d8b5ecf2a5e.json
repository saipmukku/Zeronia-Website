{"ast":null,"code":"/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from './globals.js';\nimport { minValue, tickModes, valueTypes, compositionTypes, tweenTypes, transformsSymbol, transformsFragmentStrings, emptyString } from './consts.js';\nimport { forEachChildren, round, now, clamp, lerp } from './helpers.js';\n\n/**\n *   @import {\n *   Tickable,\n *   Renderable,\n *   CallbackArgument,\n *   Tween,\n *   DOMTarget,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */tickable._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */tickable);\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */tickable);\n  }\n  if (forcedTick || tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime ||\n  // Normal render\n  time <= tickableDelay && tickablePrevTime > tickableDelay ||\n  // Playhead is before the animation start time so make sure the animation is at its initial state\n  time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n  ) || iterationTime >= tickableEndTime && tickablePrevTime !== duration || iterationTime <= tickableDelay && tickablePrevTime > 0 || time <= tickablePrevTime && tickablePrevTime === duration && completed ||\n  // Force a render if a seek occurs on an completed animation\n  isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */tickable);\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */ /** @type {JSAnimation} */tickable._head;\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n      while (tween) {\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n        if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime) && (!tweenPrevRep || tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay))) {\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */tweenModifier(round(lerp(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */tweenModifier(round(lerp(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */tweenModifier(lerp(fn[0], tn[0], tweenProgress)), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */tweenModifier(lerp(fn[1], tn[1], tweenProgress)), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */tweenModifier(lerp(fn[2], tn[2], tweenProgress)), 0, 255), 0);\n            const a = clamp(/** @type {Number} */tweenModifier(round(lerp(fn[3], tn[3], tweenProgress), tweenPrecision)), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */tweenModifier(round(lerp(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */tweenTarget.setAttribute(tweenProperty, /** @type {String} */value);\n            } else {\n              tweenStyle = /** @type {DOMTarget} */tweenTarget.style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty, /** @type {String} */value);\n              }\n            }\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n        tween = tween._next;\n      }\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */tickable.onRender(/** @type {JSAnimation} */tickable);\n      }\n    }\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */tickable);\n    }\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (\n    // (tickableAbsoluteTime > 0 instead) of (tickableAbsoluteTime >= duration) to prevent floating point precision issues\n    // see: https://github.com/juliangarnier/anime/issues/1088\n    parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {\n      tickable.onComplete(/** @type {CallbackArgument} */tickable);\n      tickable.completed = !isRunningBackwards;\n    }\n    // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */tickable);\n          tickable._resolve(/** @type {CallbackArgument} */tickable);\n        }\n      }\n    }\n    // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */tickable;\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */tl);\n    }\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */tl);\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */tl);\n          tl._resolve(/** @type {CallbackArgument} */tl);\n        }\n      }\n    }\n  }\n};\nexport { render, tick };","map":{"version":3,"names":["globals","minValue","tickModes","valueTypes","compositionTypes","tweenTypes","transformsSymbol","transformsFragmentStrings","emptyString","forEachChildren","round","now","clamp","lerp","render","tickable","time","muteCallbacks","internalRender","tickMode","parent","duration","completed","iterationDuration","iterationCount","_currentIteration","_loopDelay","_reversed","_alternate","_hasChildren","tickableDelay","_delay","tickablePrevAbsoluteTime","_currentTime","tickableEndTime","tickableAbsoluteTime","tickablePrevTime","tickableCurrentTime","deltaTime","isCurrentTimeAboveZero","isCurrentTimeEqualOrAboveDuration","isSetter","forcedTick","FORCE","isOdd","iterationElapsedTime","hasRendered","currentIteration","isReversed","_ease","iterationTime","isRunningBackwards","backwards","_iterationTime","began","onBegin","onLoop","AUTO","computeDeltaTime","onBeforeUpdate","forcedRender","tickThreshold","absoluteTime","_offset","tween","_head","tweenTarget","tweenStyle","tweenTargetTransforms","tweenTargetTransformsProperties","tweenTransformsNeedUpdate","tweenComposition","_composition","tweenCurrentTime","tweenChangeDuration","_changeDuration","tweenAbsEndTime","_absoluteStartTime","tweenNextRep","_nextRep","tweenPrevRep","_prevRep","tweenHasComposition","none","_isOverridden","_isOverlapped","tweenNewTime","_startTime","tweenProgress","_updateDuration","tweenModifier","_modifier","tweenValueType","_valueType","tweenType","_tweenType","tweenIsObject","OBJECT","tweenIsNumber","NUMBER","tweenPrecision","precision","value","number","_fromNumber","_toNumber","UNIT","_unit","COLOR","fn","_fromNumbers","tn","_toNumbers","r","g","b","a","ns","_numbers","COMPLEX","_strings","j","l","length","n","s","_number","blend","tweenProperty","property","target","ATTRIBUTE","setAttribute","style","TRANSFORM","CSS","CSS_VAR","setProperty","_value","_renderTransforms","str","key","transform","_next","onRender","onUpdate","onComplete","Infinity","paused","_resolve","tick","tl","tlIsRunningBackwards","tlChildrenTime","tlCildrenTickTime","tlChildrenHasRendered","tlChildrenHaveCompleted","tlIterationDuration","child","childDuration","childStartTime","childEndTime","childTime","_speed","childTickMode","_fps","requestTick"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/core/render.js"],"sourcesContent":["/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from './globals.js';\nimport { minValue, tickModes, valueTypes, compositionTypes, tweenTypes, transformsSymbol, transformsFragmentStrings, emptyString } from './consts.js';\nimport { forEachChildren, round, now, clamp, lerp } from './helpers.js';\n\n/**\n *   @import {\n *   Tickable,\n *   Renderable,\n *   CallbackArgument,\n *   Tween,\n *   DOMTarget,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */(tickable)._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */(tickable));\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */(tickable));\n  }\n\n  if (\n    forcedTick ||\n    tickMode === tickModes.AUTO && (\n      time >= tickableDelay && time <= tickableEndTime || // Normal render\n      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) ||\n    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||\n    iterationTime <= tickableDelay && tickablePrevTime > 0 ||\n    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n\n      while (tween) {\n\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n\n        if ((forcedRender || (\n            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&\n            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)\n          )) && (!tweenHasComposition || (\n            !tween._isOverridden &&\n            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&\n            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&\n            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))\n          ))\n        ) {\n\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */(tweenModifier(round(lerp(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */(tweenModifier(round(lerp(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */(tweenModifier(lerp(fn[0], tn[0], tweenProgress))), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */(tweenModifier(lerp(fn[1], tn[1], tweenProgress))), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */(tweenModifier(lerp(fn[2], tn[2], tweenProgress))), 0, 255), 0);\n            const a = clamp(/** @type {Number} */(tweenModifier(round(lerp(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */(tweenModifier(round(lerp(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));\n            } else {\n              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));\n              }\n            }\n\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n\n        tween = tween._next;\n      }\n\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));\n      }\n    }\n\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (\n      // (tickableAbsoluteTime > 0 instead) of (tickableAbsoluteTime >= duration) to prevent floating point precision issues\n      // see: https://github.com/juliangarnier/anime/issues/1088\n      (parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed) ||\n      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)\n    )) {\n      tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n      tickable.completed = !isRunningBackwards;\n    }\n  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n          tickable._resolve(/** @type {CallbackArgument} */(tickable));\n        }\n      }\n    }\n  // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */(tickable);\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));\n    }\n\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */(tl));\n          tl._resolve(/** @type {CallbackArgument} */(tl));\n        }\n      }\n    }\n  }\n};\n\nexport { render, tick };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}