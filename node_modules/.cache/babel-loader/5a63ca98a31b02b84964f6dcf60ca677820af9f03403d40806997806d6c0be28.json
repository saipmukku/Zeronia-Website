{"ast":null,"code":"/**\n * Anime.js - text - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isBrowser, doc } from '../core/consts.js';\nimport { scope } from '../core/globals.js';\nimport { isArr, isObj, isFnc, isUnd, isStr, isNum } from '../core/helpers.js';\nimport { getNodeList } from '../core/targets.js';\nimport { setValue } from '../core/values.js';\nimport { keepTime } from '../utils/time.js';\n\n/**\n * @import {\n *   Tickable,\n *   DOMTarget,\n *   SplitTemplateParams,\n *   SplitFunctionValue,\n *   TextSplitterParams,\n * } from '../types/index.js'\n*/\n\nconst segmenter = typeof Intl !== 'undefined' && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike || seg.segment === ' ' ||\n  // Consider spaces as words first, then handle them diffrently later\n  isNum(+seg.segment); // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [...(/** @type {*} */$el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\nconst debugColors = {\n  line: '#00D672',\n  word: '#FF4B4B',\n  char: '#5A87FF'\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */$el.children[i], lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {SplitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template.replace(valueRgx, `<i class=\"${className}\"></i>`).replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */$content.firstElementChild;\n  const $split = /** @type {HTMLElement} */$content.querySelector(`[data-${type}]`) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */$content.querySelectorAll(`i.${className}`);\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */node.innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], {\n      granularity: wordType\n    }) : {\n      segment: text => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment) // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], {\n      granularity: 'grapheme'\n    }) : {\n      segment: text => [...text].map(char => ({\n        segment: char\n      }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const {\n      words,\n      chars,\n      lines,\n      accessible,\n      includeSpaces,\n      debug\n    } = parameters;\n    const $target = /** @type {HTMLElement} */(target = isArr(target) ? target[0] : target) && /** @type {Node} */target.nodeType ? target : (getNodeList(target) || [])[0];\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && !wordParams && !charParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {SplitTemplateParams} */lineParams) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {SplitTemplateParams} */wordParams) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {SplitTemplateParams} */charParams) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */$target.offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = keepTime(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || isWordLike && prevSeg && isSegmentWordLike(prevSeg)) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */$charsFragment, charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */[...(/** @type {*} */node.childNodes)];\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y,\n      linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const {\n        top,\n        height\n      } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */$el.cloneNode(true);\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */$el.offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst splitText = (target, parameters) => new TextSplitter(target, parameters);\n\n/**\n * @deprecated text.split() is deprecated, import splitText() directly, or text.splitText()\n *\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => {\n  console.warn('text.split() is deprecated, import splitText() directly, or text.splitText()');\n  return new TextSplitter(target, parameters);\n};\nexport { TextSplitter, split, splitText };","map":{"version":3,"names":["isBrowser","doc","scope","isArr","isObj","isFnc","isUnd","isStr","isNum","getNodeList","setValue","keepTime","segmenter","Intl","Segmenter","valueRgx","indexRgx","whiteSpaceGroupRgx","whiteSpaceRgx","lineType","wordType","charType","dataLine","wordSegmenter","graphemeSegmenter","$splitTemplate","isSegmentWordLike","seg","isWordLike","segment","setAriaHidden","$el","setAttribute","getAllTopLevelElements","type","querySelectorAll","debugColors","line","word","char","filterEmptyElements","childElementCount","textContent","trim","$parent","parentElement","remove","filterLineElements","lineIndex","bin","dataLineAttr","getAttribute","tagName","add","i","children","generateTemplate","params","template","classString","class","cloneType","clone","wrapType","wrap","overflow","left","top","processHTMLTemplate","htmlTemplate","store","node","$parentFragment","debug","wordIndex","charIndex","isLine","isChar","className","displayStyle","innerHTML","replace","$content","content","$highestParent","firstElementChild","$split","querySelector","$replacables","replacablesLength","length","style","display","$replace","$closestParent","replaceChild","cloneNode","push","appendChild","console","warn","outline","TextSplitter","constructor","target","parameters","granularity","text","segments","words","split","l","test","map","createElement","current","register","chars","lines","accessible","includeSpaces","$target","nodeType","lineParams","wordParams","charParams","linesOnly","lineTemplate","wordTemplate","charTemplate","html","effects","effectsCleanups","cache","ready","width","resizeTimeout","handleSplit","resizeObserver","ResizeObserver","clearTimeout","setTimeout","currentWidth","offsetWidth","fonts","then","observe","addEffect","effect","refreshableEffect","revert","disconnect","forEach","cleanup","splitNode","nodeText","nodeValue","tempWords","wordSegments","$wordsFragment","createDocumentFragment","prevSeg","wordSegment","lastWordIndex","lastWord","includes","createTextNode","nextWord","hasWordFollowingSpace","wordToProcess","charSegments","$charsFragment","charSegmentsArray","j","jl","charSegment","isLastChar","charText","$charNode","parentNode","childNodes","clearCache","isCached","fontsReady","status","canSplitLines","elementsArray","y","linesCount","height","getBoundingClientRect","nested","c","linesFragment","parents","Set","clones","$clone","cloneIndex","clonesLength","w","$word","replaceWith","$accessible","cssText","insertBefore","firstChild","refresh","splitText"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/text/split.js"],"sourcesContent":["/**\n * Anime.js - text - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isBrowser, doc } from '../core/consts.js';\nimport { scope } from '../core/globals.js';\nimport { isArr, isObj, isFnc, isUnd, isStr, isNum } from '../core/helpers.js';\nimport { getNodeList } from '../core/targets.js';\nimport { setValue } from '../core/values.js';\nimport { keepTime } from '../utils/time.js';\n\n/**\n * @import {\n *   Tickable,\n *   DOMTarget,\n *   SplitTemplateParams,\n *   SplitFunctionValue,\n *   TextSplitterParams,\n * } from '../types/index.js'\n*/\n\nconst segmenter = (typeof Intl !== 'undefined') && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike ||\n         seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later\n         isNum(+seg.segment);   // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\n\nconst debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {SplitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template\n    .replace(valueRgx, `<i class=\"${className}\"></i>`)\n    .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);\n  const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {\n      segment: (text) => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {\n      segment: text => [...text].map(char => ({ segment: char }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const { words, chars, lines, accessible, includeSpaces, debug } = parameters;\n    const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && (!wordParams && !charParams);\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {SplitTemplateParams} */(lineParams)) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {SplitTemplateParams} */(wordParams)) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {SplitTemplateParams} */(charParams)) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = keepTime(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y, linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const { top, height } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */($el.cloneNode(true));\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */($el).offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst splitText = (target, parameters) => new TextSplitter(target, parameters);\n\n/**\n * @deprecated text.split() is deprecated, import splitText() directly, or text.splitText()\n *\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => {\n  console.warn('text.split() is deprecated, import splitText() directly, or text.splitText()');\n  return new TextSplitter(target, parameters);\n};\n\nexport { TextSplitter, split, splitText };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}