{"ast":null,"code":"/**\n * Anime.js - timeline - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { relativeValuesExecRgx, minValue } from '../core/consts.js';\nimport { isUnd, isNum, stringStartsWith, isNil } from '../core/helpers.js';\nimport { getRelativeValue } from '../core/values.js';\n\n/**\n * @import {\n *   Tickable,\n *   TimelinePosition,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from './timeline.js'\n*/\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */timeline._tail;\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimelinePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */timePosition;\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset : hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] : tlDuration : tlDuration;\n  }\n};\nexport { parseTimelinePosition };","map":{"version":3,"names":["relativeValuesExecRgx","minValue","isUnd","isNum","stringStartsWith","isNil","getRelativeValue","getPrevChildOffset","timeline","timePosition","goToPrevAnimationOffset","prevAnimation","_tail","prevOffset","_offset","_delay","duration","parseTimelinePosition","tlDuration","iterationDuration","timePosStr","tlLabels","labels","hasLabels","hasSibling","matchedRelativeOperator","exec","fullOperator","split","labelOffset","parsedOffset","parsedNumericalOffset"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/timeline/position.js"],"sourcesContent":["/**\n * Anime.js - timeline - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { relativeValuesExecRgx, minValue } from '../core/consts.js';\nimport { isUnd, isNum, stringStartsWith, isNil } from '../core/helpers.js';\nimport { getRelativeValue } from '../core/values.js';\n\n/**\n * @import {\n *   Tickable,\n *   TimelinePosition,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from './timeline.js'\n*/\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */(timeline._tail);\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimelinePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */(timePosition);\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset :\n           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :\n           tlDuration : tlDuration;\n  }\n};\n\nexport { parseTimelinePosition };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,qBAAqB,EAAEC,QAAQ,QAAQ,mBAAmB;AACnE,SAASC,KAAK,EAAEC,KAAK,EAAEC,gBAAgB,EAAEC,KAAK,QAAQ,oBAAoB;AAC1E,SAASC,gBAAgB,QAAQ,mBAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAGA,CAACC,QAAQ,EAAEC,YAAY,KAAK;EACrD,IAAIL,gBAAgB,CAACK,YAAY,EAAE,GAAG,CAAC,EAAE;IACvC,MAAMC,uBAAuB,GAAGD,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG;IACvD,MAAME,aAAa,GAAG,uBAAwBH,QAAQ,CAACI,KAAM;IAC7D,MAAMC,UAAU,GAAGF,aAAa,GAAGA,aAAa,CAACG,OAAO,GAAGH,aAAa,CAACI,MAAM,GAAG,CAAC;IACnF,OAAOL,uBAAuB,GAAGG,UAAU,GAAGA,UAAU,GAAGF,aAAa,CAACK,QAAQ;EACnF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAGA,CAACT,QAAQ,EAAEC,YAAY,KAAK;EACxD,IAAIS,UAAU,GAAGV,QAAQ,CAACW,iBAAiB;EAC3C,IAAID,UAAU,KAAKjB,QAAQ,EAAEiB,UAAU,GAAG,CAAC;EAC3C,IAAIhB,KAAK,CAACO,YAAY,CAAC,EAAE,OAAOS,UAAU;EAC1C,IAAIf,KAAK,CAAC,CAACM,YAAY,CAAC,EAAE,OAAO,CAACA,YAAY;EAC9C,MAAMW,UAAU,GAAG,qBAAsBX,YAAa;EACtD,MAAMY,QAAQ,GAAGb,QAAQ,GAAGA,QAAQ,CAACc,MAAM,GAAG,IAAI;EAClD,MAAMC,SAAS,GAAG,CAAClB,KAAK,CAACgB,QAAQ,CAAC;EAClC,MAAMR,UAAU,GAAGN,kBAAkB,CAACC,QAAQ,EAAEY,UAAU,CAAC;EAC3D,MAAMI,UAAU,GAAG,CAACtB,KAAK,CAACW,UAAU,CAAC;EACrC,MAAMY,uBAAuB,GAAGzB,qBAAqB,CAAC0B,IAAI,CAACN,UAAU,CAAC;EACtE,IAAIK,uBAAuB,EAAE;IAC3B,MAAME,YAAY,GAAGF,uBAAuB,CAAC,CAAC,CAAC;IAC/C,MAAMG,KAAK,GAAGR,UAAU,CAACQ,KAAK,CAACD,YAAY,CAAC;IAC5C,MAAME,WAAW,GAAGN,SAAS,IAAIK,KAAK,CAAC,CAAC,CAAC,GAAGP,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGV,UAAU;IAC3E,MAAMY,YAAY,GAAGN,UAAU,GAAGX,UAAU,GAAGU,SAAS,GAAGM,WAAW,GAAGX,UAAU;IACnF,MAAMa,qBAAqB,GAAG,CAACH,KAAK,CAAC,CAAC,CAAC;IACvC,OAAOtB,gBAAgB,CAACwB,YAAY,EAAEC,qBAAqB,EAAEJ,YAAY,CAAC,CAAC,CAAC,CAAC;EAC/E,CAAC,MAAM;IACL,OAAOH,UAAU,GAAGX,UAAU,GACvBU,SAAS,GAAG,CAACrB,KAAK,CAACmB,QAAQ,CAACD,UAAU,CAAC,CAAC,GAAGC,QAAQ,CAACD,UAAU,CAAC,GAC/DF,UAAU,GAAGA,UAAU;EAChC;AACF,CAAC;AAED,SAASD,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}