{"ast":null,"code":"/**\n * Anime.js - events - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { noop, doc, isDomSymbol, relativeValuesExecRgx, win } from '../core/consts.js';\nimport { scope, globals } from '../core/globals.js';\nimport { isUnd, isNum, addChild, forEachChildren, round, isStr, isObj, removeChild, clamp, lerp, isFnc } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\nimport { setValue, getRelativeValue, decomposeRawValue, decomposedOriginalValue } from '../core/values.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { Timer } from '../timer/timer.js';\nimport { get, set } from '../utils/target.js';\nimport { sync } from '../utils/time.js';\nimport { none } from '../easings/none.js';\nimport { parseEase } from '../easings/eases/parser.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   EasingFunction,\n *   Callback,\n *   EasingParam,\n *   ScrollThresholdValue,\n *   ScrollObserverParams,\n *   Tickable,\n *   ScrollThresholdParam,\n *   ScrollThresholdCallback,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */value(scroller) : (/** @type {T} */value);\nconst scrollContainers = new Map();\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.scale = 1;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: (/** @type {Timer} */self) => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = $el.clientWidth;\n      height = $el.clientHeight;\n      this.top = elRect.top;\n      this.left = elRect.left;\n      this.scale = elRect.width ? width / elRect.width : elRect.height ? height / elRect.height : 1;\n    }\n    this.width = width;\n    this.height = height;\n  }\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */target ? parseTargets(target)[0] || doc.body : doc.body;\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 : v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' : v === 'center' ? '50%' : v;\n  const {\n    n,\n    u\n  } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = n / 100 * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */v);\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */v.split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */v;\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */target;\n      break;\n    }\n  }\n  return $linkedTarget;\n};\nlet scrollerIndex = 0;\nconst debugColors = ['#FF4B4B', '#FF971B', '#FFC730', '#F9F640', '#7AFF5A', '#18FF74', '#17E09B', '#3CFFEC', '#05DBE9', '#33B3F1', '#638CF9', '#C563FE', '#FF4FCF', '#F93F8A'];\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEase(/** @type {EasingParam} */syncMode) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && isStr(syncMode) && !isEase && !isSmooth;\n    const syncMethods = isMethods ? /** @type {String} */syncMode.split(' ').map((/** @type {String} */m) => () => {\n      const linked = this.linked;\n      return linked && linked[m] ? linked[m]() : null;\n    }) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : (/** @type {Number} */syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.ready = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */parseTargets(parameters.target)[0];\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Forces WAAPI Animation to persist; otherwise, they will stop syncing on finish.\n      if (!isUnd(/** @type {WAAPIAnimation} */linked)) /** @type {WAAPIAnimation} */linked.persist = true;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */linked.targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */linked);\n        } else {\n          forEachChildren(/** @type {Timeline} */linked, (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */child);\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n  get velocity() {\n    return this.container.velocity;\n  }\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n  refresh() {\n    // This flag is used to prevent running handleScroll() outside of this.refresh() with values not yet calculated\n    this.ready = true;\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors[this.index % debugColors.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px ' + v + 'px' : v + 'px' + ' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = c => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half - 10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half - 10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${size / 2 - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = get(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = set(container.element, {\n        position: 'relative '\n      });\n    }\n  }\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = get(container.element, 'position') === 'static' ? set(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = get($el, 'position') === 'sticky' ?\n    //                    set($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */\n    $el.parentElement;\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = get($el, 'position') === 'sticky' ? set($el, {\n        position: 'static'\n      }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const scale = container.scale;\n    const offset = (isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top) * scale;\n    const targetSize = (isHori ? rect.width : rect.height) * scale;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */enter.split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */enter;\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */enter;\n    }\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */leave.split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */leave;\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */leave;\n    }\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = parsedEnterTarget + offset - containerSize;\n    const over = parsedLeaveTarget + offset - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n  handleScroll() {\n    if (!this.ready) return;\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */syncSmooth < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;\n          p = round(lerp(lp, p, lerp(.01, .2, /** @type {Number} */syncSmooth)) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && syncSmooth && lp) {\n        container.wakeTicker.restart();\n      }\n    }\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if (isInView && !this.isInView || forceEnter && !this.forceEnter && !this.hasEntered) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if (!this.repeat && !linked || !this.repeat && linked && linked.completed) {\n        this.revert();\n      }\n    }\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n    this.prevProgress = p;\n  }\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    this.ready = false;\n    return this;\n  }\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\nexport { ScrollObserver, onScroll, scrollContainers };","map":{"version":3,"names":["noop","doc","isDomSymbol","relativeValuesExecRgx","win","scope","globals","isUnd","isNum","addChild","forEachChildren","round","isStr","isObj","removeChild","clamp","lerp","isFnc","parseTargets","setValue","getRelativeValue","decomposeRawValue","decomposedOriginalValue","convertValueUnit","Timer","get","set","sync","none","parseEase","getMaxViewHeight","$el","createElement","body","appendChild","style","height","offsetHeight","parseScrollObserverFunctionParameter","value","scroller","scrollContainers","Map","ScrollContainer","constructor","element","useWin","winWidth","winHeight","width","left","top","scale","zIndex","scrollX","scrollY","prevScrollX","prevScrollY","scrollWidth","scrollHeight","velocity","backwardX","backwardY","scrollTicker","autoplay","onBegin","dataTimer","resume","onUpdate","backwards","child","handleScroll","onComplete","pause","init","frameRate","self","dt","deltaTime","px","py","nx","ny","dx","dy","Math","sqrt","resizeTicker","duration","timeScale","updateWindowBounds","refreshScrollObservers","wakeTicker","_head","_tail","updateScrollCoords","updateBounds","resizeObserver","ResizeObserver","restart","observe","addEventListener","scrollLeft","scrollTop","innerWidth","getComputedStyle","parseFloat","marginLeft","marginRight","marginTop","marginBottom","elRect","getBoundingClientRect","clientWidth","clientHeight","_debug","removeDebug","refresh","debug","handleEvent","e","type","revert","cancel","disconnect","removeEventListener","delete","registerAndGetScrollContainer","target","scrollContainer","convertValueToPx","v","size","under","over","clampMin","clampMax","n","u","parseBoundValue","matchedOperator","exec","splitter","operator","splitted","split","valueAPx","valueBPx","min","max","getAnimationDomTarget","linked","$linkedTarget","linkedTargets","targets","i","l","length","scrollerIndex","debugColors","ScrollObserver","parameters","current","register","syncMode","ease","isLinear","isEase","isSmooth","isMethods","syncMethods","map","m","biDirSync","index","id","container","repeat","horizontal","enter","leave","syncEase","syncSmooth","onSyncEnter","onSyncLeave","onSyncEnterForward","onSyncLeaveForward","onSyncEnterBackward","onSyncLeaveBackward","onEnter","onLeave","onEnterForward","onLeaveForward","onEnterBackward","onLeaveBackward","onSyncComplete","reverted","ready","completed","began","isInView","forceEnter","hasEntered","offset","offsetStart","offsetEnd","distance","prevProgress","thresholds","coords","debugStyles","$debug","_params","_next","_prev","link","persist","backward","scroll","progress","p","Infinity","isNaN","params","axis","parentNode","isHori","$existingDebug","querySelector","$thresholds","$triggers","color","containerWidth","containerHeight","offLeft","offTop","half","labelHeight","labelWidth","labelSize","gradientOffset","lineCSS","c","baseCSS","t","w","h","cssText","labels","forEach","isView","isTail","isFirst","isOver","isFlip","$label","$text","dirProp","flipOffset","innerHTML","position","classList","add","containerPosition","stickys","$target","linkedTime","currentTime","seek","parentElement","isSticky","push","rect","targetSize","containerSize","scrollSize","maxScroll","enterTarget","leaveTarget","enterContainer","leaveContainer","parsedEnterTarget","parsedLeaveTarget","parsedEnterContainer","parsedLeaveContainer","scrollDelta","sticky","shouldSeek","isBefore","isAfter","isOnTheEdge","hasUpdated","syncCompleted","lp","step","snap","onScroll"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/events/scroll.js"],"sourcesContent":["/**\n * Anime.js - events - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { noop, doc, isDomSymbol, relativeValuesExecRgx, win } from '../core/consts.js';\nimport { scope, globals } from '../core/globals.js';\nimport { isUnd, isNum, addChild, forEachChildren, round, isStr, isObj, removeChild, clamp, lerp, isFnc } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\nimport { setValue, getRelativeValue, decomposeRawValue, decomposedOriginalValue } from '../core/values.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { Timer } from '../timer/timer.js';\nimport { get, set } from '../utils/target.js';\nimport { sync } from '../utils/time.js';\nimport { none } from '../easings/none.js';\nimport { parseEase } from '../easings/eases/parser.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   EasingFunction,\n *   Callback,\n *   EasingParam,\n *   ScrollThresholdValue,\n *   ScrollObserverParams,\n *   Tickable,\n *   ScrollThresholdParam,\n *   ScrollThresholdCallback,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : /** @type {T} */(value);\n\nconst scrollContainers = new Map();\n\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.scale = 1;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: (/** @type {Timer} */self) => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = $el.clientWidth;\n      height = $el.clientHeight;\n      this.top = elRect.top;\n      this.left = elRect.left;\n      this.scale = elRect.width ? width / elRect.width : (elRect.height ? height / elRect.height : 1);\n    }\n    this.width = width;\n    this.height = height;\n  }\n\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :\n                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :\n                v === 'center' ? '50%' :\n                v;\n  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = (n / 100) * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */(v).split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */(v);\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */(target);\n      break;\n    }\n  }\n  return $linkedTarget;\n};\n\nlet scrollerIndex = 0;\n\nconst debugColors = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];\n\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEase(/** @type {EasingParam} */(syncMode)) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);\n    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(\n      (/** @type {String} */m) => () => {\n        const linked = this.linked;\n        return linked && linked[m] ? linked[m]() : null;\n      }\n    ) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.ready = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Forces WAAPI Animation to persist; otherwise, they will stop syncing on finish.\n      if (!isUnd(/** @type {WAAPIAnimation} */(linked))) /** @type {WAAPIAnimation} */(linked).persist = true;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));\n        } else {\n          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n\n  get velocity() {\n    return this.container.velocity;\n  }\n\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n\n  refresh() {\n    // This flag is used to prevent running handleScroll() outside of this.refresh() with values not yet calculated\n    this.ready = true;\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors[this.index % debugColors.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${(size / 2) - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = get(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = set(container.element, { position: 'relative '});\n    }\n\n  }\n\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = get(container.element, 'position') === 'static' ? set(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = get($el, 'position') === 'sticky' ?\n    //                    set($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */($el.parentElement);\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = get($el, 'position') === 'sticky' ? set($el, { position: 'static' }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const scale = container.scale;\n    const offset = (isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top) * scale;\n    const targetSize = (isHori ? rect.width : rect.height) * scale;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */(enter).split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */(enter);\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */(enter);\n    }\n\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */(leave).split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */(leave);\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */(leave);\n    }\n\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = (parsedEnterTarget + offset) - containerSize;\n    const over = (parsedLeaveTarget + offset) - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n\n  handleScroll() {\n    if (!this.ready) return;\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */(syncSmooth) < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;\n          p = round(lerp(lp, p, lerp(.01, .2, /** @type {Number} */(syncSmooth))) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {\n        container.wakeTicker.restart();\n      }\n    }\n\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {\n        this.revert();\n      }\n    }\n\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n\n    this.prevProgress = p;\n  }\n\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    this.ready = false;\n    return this;\n  }\n\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\n\nexport { ScrollObserver, onScroll, scrollContainers };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}