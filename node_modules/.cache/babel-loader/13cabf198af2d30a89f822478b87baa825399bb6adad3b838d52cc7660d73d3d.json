{"ast":null,"code":"/**\n * Anime.js - timeline - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from '../core/globals.js';\nimport { minValue, compositionTypes, tickModes } from '../core/consts.js';\nimport { mergeObjects, isObj, isFnc, isUnd, isStr, normalizeTime, forEachChildren, isNum, addChild, clampInfinity } from '../core/helpers.js';\nimport { setValue } from '../core/values.js';\nimport { parseTargets } from '../core/targets.js';\nimport { tick } from '../core/render.js';\nimport { cleanInlineStyles } from '../core/styles.js';\nimport { removeTargetsFromRenderable } from '../animation/composition.js';\nimport { JSAnimation } from '../animation/animation.js';\nimport { Timer } from '../timer/timer.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { parseTimelinePosition } from './position.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   Callback,\n *   Tickable,\n *   TimerParams,\n *   AnimationParams,\n *   Target,\n *   Renderable,\n *   TimelineParams,\n *   DefaultsParams,\n *   TimelinePosition,\n *   StaggerFunction,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity((tl.iterationDuration + tl._loopDelay) * tl.iterationCount - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */childParams.duration <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ? new JSAnimation(targets, /** @type {AnimationParams} */childParams, tl, adjustedPosition, false, index, length) : new Timer(/** @type {TimerParams} */childParams, tl, adjustedPosition);\n  tlChild.init(true);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\nclass Timeline extends Timer {\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */parameters, null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEase(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimelinePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {TimelinePosition|AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */a2;\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = a3;\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */a1);\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          /** @type {Number} */\n          const parsedLength = parsedTargetsArray.length;\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = {\n              ...childParams\n            };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(staggeredChildParams, this, parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)), target, i, parsedLength);\n            i++;\n          });\n        } else {\n          addTlChild(childParams, this, parseTimelinePosition(this, a3), /** @type {TargetsParam} */a1);\n        }\n      } else {\n        // It's a Timer\n        addTlChild(/** @type TimerParams */a1, this, parseTimelinePosition(this, a2));\n      }\n      return this.init(true);\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */synced.effect ? /** @type {globalThis.Animation} */synced.effect.getTiming().duration : /** @type {Tickable} */synced.duration);\n    return this.add(synced, {\n      currentTime: [0, duration],\n      duration,\n      ease: 'linear'\n    }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimelinePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({\n      duration: 0,\n      onComplete: () => callback(this)\n    }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this, position);\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    removeTargetsFromRenderable(parseTargets(targets), this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedTimeline\n   */\n\n  /**\n   * @param  {Callback<ResolvedTimeline>} [callback]\n   * @return Promise<this>\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\nexport { Timeline, createTimeline };","map":{"version":3,"names":["globals","minValue","compositionTypes","tickModes","mergeObjects","isObj","isFnc","isUnd","isStr","normalizeTime","forEachChildren","isNum","addChild","clampInfinity","setValue","parseTargets","tick","cleanInlineStyles","removeTargetsFromRenderable","JSAnimation","Timer","parseEase","parseTimelinePosition","getTimelineTotalDuration","tl","iterationDuration","_loopDelay","iterationCount","addTlChild","childParams","timePosition","targets","index","length","isSetter","duration","adjustedPosition","AUTO","tlChild","init","child","childTLOffset","_offset","_delay","childDur","Timeline","constructor","parameters","labels","defaultsParams","defaults","globalDefaults","onRender","tlPlaybackEase","playbackEase","_ease","add","a1","a2","a3","isAnim","isTimer","_hasChildren","staggeredPosition","parsedTargetsArray","tlDuration","tlIterationDuration","id","i","parsedLength","forEach","target","staggeredChildParams","sync","synced","position","pause","effect","getTiming","currentTime","ease","set","composition","replace","call","callback","onComplete","label","labelName","remove","propertyName","stretch","newDuration","currentDuration","timeScale","refresh","revert","then","createTimeline"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/timeline/timeline.js"],"sourcesContent":["/**\n * Anime.js - timeline - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from '../core/globals.js';\nimport { minValue, compositionTypes, tickModes } from '../core/consts.js';\nimport { mergeObjects, isObj, isFnc, isUnd, isStr, normalizeTime, forEachChildren, isNum, addChild, clampInfinity } from '../core/helpers.js';\nimport { setValue } from '../core/values.js';\nimport { parseTargets } from '../core/targets.js';\nimport { tick } from '../core/render.js';\nimport { cleanInlineStyles } from '../core/styles.js';\nimport { removeTargetsFromRenderable } from '../animation/composition.js';\nimport { JSAnimation } from '../animation/animation.js';\nimport { Timer } from '../timer/timer.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { parseTimelinePosition } from './position.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   Callback,\n *   Tickable,\n *   TimerParams,\n *   AnimationParams,\n *   Target,\n *   Renderable,\n *   TimelineParams,\n *   DefaultsParams,\n *   TimelinePosition,\n *   StaggerFunction,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ?\n    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :\n    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);\n  tlChild.init(true);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\n\nclass Timeline extends Timer {\n\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEase(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimelinePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {TimelinePosition|AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */(a2);\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = a3;\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          /** @type {Number} */\n          const parsedLength = (parsedTargetsArray.length);\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = { ...childParams };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(\n              staggeredChildParams,\n              this,\n              parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),\n              target,\n              i,\n              parsedLength\n            );\n            i++;\n          });\n        } else {\n          addTlChild(\n            childParams,\n            this,\n            parseTimelinePosition(this, a3),\n            /** @type {TargetsParam} */(a1),\n          );\n        }\n      } else {\n        // It's a Timer\n        addTlChild(\n          /** @type TimerParams */(a1),\n          this,\n          parseTimelinePosition(this,a2),\n        );\n      }\n      return this.init(true);\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);\n    return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimelinePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({ duration: 0, onComplete: () => callback(this) }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this, position);\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    removeTargetsFromRenderable(parseTargets(targets), this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedTimeline\n   */\n\n  /**\n   * @param  {Callback<ResolvedTimeline>} [callback]\n   * @return Promise<this>\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\n\nexport { Timeline, createTimeline };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}