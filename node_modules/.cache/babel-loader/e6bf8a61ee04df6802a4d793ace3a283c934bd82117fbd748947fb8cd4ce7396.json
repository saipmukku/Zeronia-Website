{"ast":null,"code":"/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { K, compositionTypes, valueTypes, minValue, tweenTypes } from '../core/consts.js';\nimport { mergeObjects, isUnd, isKey, isObj, round, cloneArray, isNil, addChild, forEachChildren, clampInfinity, normalizeTime, isArr, isNum } from '../core/helpers.js';\nimport { globals } from '../core/globals.js';\nimport { registerTargets } from '../core/targets.js';\nimport { setValue, getTweenType, getFunctionValue, decomposeRawValue, createDecomposedValueTargetObject, getOriginalAnimatableValue, decomposedOriginalValue, getRelativeValue, decomposeTweenValue } from '../core/values.js';\nimport { sanitizePropertyName, cleanInlineStyles } from '../core/styles.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { Timer } from '../timer/timer.js';\nimport { getTweenSiblings, overrideTween, composeTween } from './composition.js';\nimport { additive } from './additive.js';\n\n/**\n * @import {\n *   Tween,\n *   TweenKeyValue,\n *   TweenParamsOptions,\n *   TweenValues,\n *   DurationKeyframes,\n *   PercentageKeyframes,\n *   AnimationParams,\n *   TweenPropValue,\n *   ArraySyntaxValue,\n *   TargetsParam,\n *   TimerParams,\n *   TweenParamValue,\n *   DOMTarget,\n *   TargetsArray,\n *   Callback,\n *   EasingFunction,\n * } from '../types/index.js'\n *\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n *\n * @import {\n *   Spring,\n * } from '../easings/spring/index.js'\n */\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst inlineStylesStore = {};\nconst toFunctionStore = {\n  func: null\n};\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = {\n  to: null\n};\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(... /** @type {DurationKeyframes} */keyframes.map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */keyframes.map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */key[p];\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */propArray;\n    }\n  } else {\n    const totalDuration = /** @type {Number} */setValue(parameters.duration, globals.defaults.duration);\n    const keys = Object.keys(keyframes).map(key => {\n      return {\n        o: parseFloat(key) / 100,\n        p: keyframes[key]\n      };\n    }).sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */properties[name];\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = {\n            to: prop[name]\n          };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n    for (let name in properties) {\n      const propArray = /** @type {Array} */properties[name];\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n  }\n  return properties;\n};\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(targets, parameters, parent, parentPosition, fastSet = false, index = 0, length = 0) {\n    super(/** @type {TimerParams & AnimationParams} */parameters, parent, parentPosition);\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */parameters.keyframes;\n    const params = /** @type {AnimationParams} */kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */kfParams, parameters), parameters) : parameters;\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender\n    } = params;\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEase(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ease.ease);\n    const tEasing = hasSpring ? /** @type {Spring} */ease.ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */ease.settlingDuration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n    // This allows targeting the current animation in the spring onComplete callback\n    if (hasSpring) /** @type {Spring} */ease.parent = this;\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n      for (let p in params) {\n        if (isKey(p)) {\n          const tweenType = getTweenType(target, p);\n          const propName = sanitizePropertyName(p, target, tweenType);\n          let propValue = params[p];\n          const isPropValueArray = isArr(propValue);\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */propValue.length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */ /** @type {unknown} */propValue;\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n              // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */\n              propValue.forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */propValue;\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n            const keyframe = keyframes[tweenIndex];\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */keyframe;\n              key = keyObjectTarget;\n            }\n            toFunctionStore.func = null;\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */keyEasing.ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */keyEasing.ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */keyEasing.settlingDuration : getFunctionValue(setValue(key.duration, l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || hasFromvalue && hasToValue;\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n            let prevSibling = prevTween;\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), decomposedOriginalValue);\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(!prevSibling ? decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), decomposedOriginalValue).n : prevSibling._toNumber, fromTargetObject.n, fromTargetObject.o);\n            }\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */target, valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets\n            let inlineValue = inlineStylesStore[propName];\n            if (!isNil(inlineValue)) inlineStylesStore[propName] = null;\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEase(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d),\n              // For additive tween and animatables\n              _number: fromTargetObject.n,\n              // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _inlineValue: inlineValue,\n              _prevRep: null,\n              // For replaced tween\n              _nextRep: null,\n              // For replaced tween\n              _prevAdd: null,\n              // For additive tween\n              _nextAdd: null,\n              // For additive tween\n              _prev: null,\n              _next: null\n            };\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n            addChild(this, tween);\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n        }\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n    }\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        // TODO: Check for from / to Array based values here,\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    // This forces setter animations to render once\n    if (this.duration === minValue) this.restart();\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedJSAnimation\n   */\n\n  /**\n   * @param  {Callback<ResolvedJSAnimation>} [callback]\n   * @return Promise<this>\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\nexport { JSAnimation, animate };","map":{"version":3,"names":["K","compositionTypes","valueTypes","minValue","tweenTypes","mergeObjects","isUnd","isKey","isObj","round","cloneArray","isNil","addChild","forEachChildren","clampInfinity","normalizeTime","isArr","isNum","globals","registerTargets","setValue","getTweenType","getFunctionValue","decomposeRawValue","createDecomposedValueTargetObject","getOriginalAnimatableValue","decomposedOriginalValue","getRelativeValue","decomposeTweenValue","sanitizePropertyName","cleanInlineStyles","convertValueUnit","parseEase","Timer","getTweenSiblings","overrideTween","composeTween","additive","fromTargetObject","toTargetObject","inlineStylesStore","toFunctionStore","func","keyframesTargetArray","fastSetValuesArray","keyObjectTarget","to","tweenId","keyframes","key","generateKeyframes","parameters","properties","propertyNames","concat","map","Object","keys","filter","i","l","length","propName","propArray","newKey","p","keyValue","totalDuration","duration","defaults","o","parseFloat","sort","a","b","forEach","offset","prop","name","prevKey","keyObj","durProgress","from","ease","push","prevEase","currentEase","undefined","shift","JSAnimation","constructor","targets","parent","parentPosition","fastSet","index","parsedTargets","targetsLength","kfParams","params","delay","playbackEase","modifier","composition","onRender","animDefaults","animaPlaybackEase","animEase","hasSpring","tEasing","tDuration","settlingDuration","tDelay","tModifier","tComposition","none","absoluteOffsetTime","_offset","iterationDuration","NaN","iterationDelay","animationAnimationLength","shouldTriggerRender","targetIndex","target","ti","tl","lastTransformGroupIndex","lastTransformGroupLength","tweenType","propValue","isPropValueArray","arrayLength","isNotObjectValue","v","siblings","prevTween","firstTweenChangeStartTime","lastTweenChangeEndTime","tweenIndex","keyframe","computedToValue","tweenToValue","tweenFromValue","keyEasing","tweenEasing","tweenDuration","tweenDelay","computedComposition","tweenComposition","tweenModifier","hasFromvalue","hasToValue","isFromToArray","isFromToValue","tweenStartTime","absoluteStartTime","prevSibling","nextSibling","_head","_isOverridden","_absoluteStartTime","_nextRep","t","NUMBER","_valueType","UNIT","u","_unit","_value","n","_toNumber","COMPLEX","complexValue","notComplexValue","s","d","unitValue","notUnitValue","COLOR","colorValue","notColorValue","valueToConvert","longestValue","shortestValue","_","tweenUpdateDuration","inlineValue","tween","id","property","_func","_ease","_fromNumbers","_toNumbers","_strings","_fromNumber","_numbers","_number","_modifier","_currentTime","_startTime","_delay","_updateDuration","_changeDuration","_tweenType","_composition","_isOverlapped","_renderTransforms","_inlineValue","_prevRep","_prevAdd","_nextAdd","_prev","_next","isNaN","TRANSFORM","blend","animation","additiveTween","console","warn","iterationCount","_loopDelay","_autoplay","stretch","newDuration","currentDuration","timeScale","refresh","tweenFunc","ogValue","restart","revert","then","callback","animate","init"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/animation/animation.js"],"sourcesContent":["/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { K, compositionTypes, valueTypes, minValue, tweenTypes } from '../core/consts.js';\nimport { mergeObjects, isUnd, isKey, isObj, round, cloneArray, isNil, addChild, forEachChildren, clampInfinity, normalizeTime, isArr, isNum } from '../core/helpers.js';\nimport { globals } from '../core/globals.js';\nimport { registerTargets } from '../core/targets.js';\nimport { setValue, getTweenType, getFunctionValue, decomposeRawValue, createDecomposedValueTargetObject, getOriginalAnimatableValue, decomposedOriginalValue, getRelativeValue, decomposeTweenValue } from '../core/values.js';\nimport { sanitizePropertyName, cleanInlineStyles } from '../core/styles.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { Timer } from '../timer/timer.js';\nimport { getTweenSiblings, overrideTween, composeTween } from './composition.js';\nimport { additive } from './additive.js';\n\n/**\n * @import {\n *   Tween,\n *   TweenKeyValue,\n *   TweenParamsOptions,\n *   TweenValues,\n *   DurationKeyframes,\n *   PercentageKeyframes,\n *   AnimationParams,\n *   TweenPropValue,\n *   ArraySyntaxValue,\n *   TargetsParam,\n *   TimerParams,\n *   TweenParamValue,\n *   DOMTarget,\n *   TargetsArray,\n *   Callback,\n *   EasingFunction,\n * } from '../types/index.js'\n *\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n *\n * @import {\n *   Spring,\n * } from '../easings/spring/index.js'\n */\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst inlineStylesStore = {};\nconst toFunctionStore = { func: null };\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = { to: null };\n\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */(key[p]);\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);\n    }\n\n  } else {\n    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));\n    const keys = Object.keys(keyframes)\n    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })\n    .sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */(properties[name]);\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = { to: prop[name] };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n\n    for (let name in properties) {\n      const propArray = /** @type {Array} */(properties[name]);\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n\n  }\n\n  return properties;\n};\n\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(\n    targets,\n    parameters,\n    parent,\n    parentPosition,\n    fastSet = false,\n    index = 0,\n    length = 0\n  ) {\n\n    super(/** @type {TimerParams & AnimationParams} */(parameters), parent, parentPosition);\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;\n    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);\n\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender,\n    } = params;\n\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEase(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */(ease).settlingDuration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n    // This allows targeting the current animation in the spring onComplete callback\n    if (hasSpring) /** @type {Spring} */(ease).parent = this;\n\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n\n      for (let p in params) {\n\n        if (isKey(p)) {\n\n          const tweenType = getTweenType(target, p);\n\n          const propName = sanitizePropertyName(p, target, tweenType);\n\n          let propValue = params[p];\n\n          const isPropValueArray = isArr(propValue);\n\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */(propValue).length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n            // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n\n            const keyframe = keyframes[tweenIndex];\n\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);\n              key = keyObjectTarget;\n            }\n\n            toFunctionStore.func = null;\n\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n\n            let prevSibling = prevTween;\n\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(\n                    getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),\n                    decomposedOriginalValue\n                  );\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(\n                !prevSibling ? decomposeRawValue(\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),\n                  decomposedOriginalValue\n                ).n : prevSibling._toNumber,\n                fromTargetObject.n,\n                fromTargetObject.o\n              );\n            }\n\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets\n            let inlineValue = inlineStylesStore[propName];\n            if (!isNil(inlineValue)) inlineStylesStore[propName] = null;\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEase(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables\n              _number: fromTargetObject.n, // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _inlineValue: inlineValue,\n              _prevRep: null, // For replaced tween\n              _nextRep: null, // For replaced tween\n              _prevAdd: null, // For additive tween\n              _nextAdd: null, // For additive tween\n              _prev: null,\n              _next: null,\n            };\n\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n\n            addChild(this, tween);\n\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n\n        }\n\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n\n    }\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        // TODO: Check for from / to Array based values here,\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    // This forces setter animations to render once\n    if (this.duration === minValue) this.restart();\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedJSAnimation\n   */\n\n  /**\n   * @param  {Callback<ResolvedJSAnimation>} [callback]\n   * @return Promise<this>\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\n\nexport { JSAnimation, animate };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}