{"ast":null,"code":"/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { proxyTargetSymbol, K } from '../core/consts.js';\nimport { isFnc, sqrt } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   DrawableSVGGeometry,\n * } from '../types/index.js'\n*/\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -pathLength * scaleFactor;\n            const d1 = v2 * pathLength * scaleFactor + os;\n            const d2 = pathLength * scaleFactor + (v1 === 0 && v2 === 1 || v1 === 1 && v2 === 0 ? 0 : 10 * scaleFactor) - d1;\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n  return /** @type {DrawableSVGGeometry} */proxy;\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(/** @type {SVGGeometryElement} */$el, start, end));\n};\nexport { createDrawable };","map":{"version":3,"names":["proxyTargetSymbol","K","isFnc","sqrt","parseTargets","getScaleFactor","$el","scaleFactor","getCTM","ctm","scaleX","a","b","scaleY","c","d","createDrawableProxy","start","end","pathLength","computedStyles","getComputedStyle","strokeLineCap","strokeLinecap","$scalled","vectorEffect","currentCap","proxy","Proxy","get","target","property","value","args","values","split","v1","v2","os","d1","d2","newCap","style","setAttribute","Reflect","apply","getAttribute","createDrawable","selector","els","map"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/svg/drawable.js"],"sourcesContent":["/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { proxyTargetSymbol, K } from '../core/consts.js';\nimport { isFnc, sqrt } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   DrawableSVGGeometry,\n * } from '../types/index.js'\n*/\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -pathLength * scaleFactor;\n            const d1 = (v2 * pathLength * scaleFactor) + os;\n            const d2 = (pathLength * scaleFactor +\n                      ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n\n  return /** @type {DrawableSVGGeometry} */(proxy);\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(\n    /** @type {SVGGeometryElement} */($el),\n    start,\n    end\n  ));\n};\n\nexport { createDrawable };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}