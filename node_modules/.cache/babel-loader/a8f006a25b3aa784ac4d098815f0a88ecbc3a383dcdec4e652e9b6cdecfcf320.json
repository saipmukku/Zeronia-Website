{"ast":null,"code":"/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { morphPointsSymbol } from '../core/consts.js';\nimport { round } from '../core/helpers.js';\nimport { getPath } from './helpers.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   FunctionValue\n * } from '../types/index.js'\n*/\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => $path1 => {\n  const tagName1 = ($path1.tagName || '').toLowerCase();\n  if (!tagName1.match(/^(path|polygon|polyline)$/)) {\n    throw new Error(`Can't morph a <${$path1.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);\n  }\n  const $path2 = /** @type {SVGGeometryElement} */getPath(path2);\n  if (!$path2) {\n    throw new Error(\"Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.\");\n  }\n  const tagName2 = ($path2.tagName || '').toLowerCase();\n  if (!tagName2.match(/^(path|polygon|polyline)$/)) {\n    throw new Error(`Can't morph a <${$path2.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);\n  }\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n  let v1 = '',\n    v2 = '';\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */$path1.getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */$path1.getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? i === 0 ? 'M' : 'L' : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n  $path1[morphPointsSymbol] = v2;\n  return [v1, v2];\n};\nexport { morphTo };","map":{"version":3,"names":["morphPointsSymbol","round","getPath","morphTo","path2","precision","$path1","tagName1","tagName","toLowerCase","match","Error","$path2","tagName2","isPath","separator","previousPoints","setAttribute","v1","v2","getAttribute","length1","getTotalLength","length2","maxPoints","Math","max","ceil","i","t","pointOnPath1","getPointAtLength","pointOnPath2","prefix","x","y"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/svg/morphto.js"],"sourcesContent":["/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { morphPointsSymbol } from '../core/consts.js';\nimport { round } from '../core/helpers.js';\nimport { getPath } from './helpers.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   FunctionValue\n * } from '../types/index.js'\n*/\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => ($path1) => {\n  const tagName1 = ($path1.tagName || '').toLowerCase();\n  if (!tagName1.match(/^(path|polygon|polyline)$/)) {\n    throw new Error(`Can't morph a <${$path1.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);\n  }\n  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));\n  if (!$path2) {\n    throw new Error(\"Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.\");\n  }\n  const tagName2 = ($path2.tagName || '').toLowerCase();\n  if (!tagName2.match(/^(path|polygon|polyline)$/)) {\n    throw new Error(`Can't morph a <${$path2.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);\n  }\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n\n  let v1 = '', v2 = '';\n\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n\n  $path1[morphPointsSymbol] = v2;\n\n  return [v1, v2];\n};\n\nexport { morphTo };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}