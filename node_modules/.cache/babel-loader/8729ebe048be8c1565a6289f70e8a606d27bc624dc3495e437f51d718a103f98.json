{"ast":null,"code":"/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { minValue, compositionTypes, tweenTypes } from '../core/consts.js';\nimport { forEachChildren, removeChild, isUnd, addChild, round, cloneArray } from '../core/helpers.js';\nimport { sanitizePropertyName } from '../core/styles.js';\nimport { engine } from '../engine/engine.js';\nimport { addAdditiveAnimation, additive } from './additive.js';\n\n/**\n * @import {\n *   TweenReplaceLookups,\n *   TweenAdditiveLookups,\n *   TweenPropertySiblings,\n *   Tween,\n *   Target,\n *   TargetsArray,\n *   Renderable,\n * } from '../types/index.js'\n *\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map()\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null\n  };\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n    const tweenAbsStartTime = tween._absoluteStartTime;\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n      // Check if the previous tween is from a different animation\n      tween.parent.id !== prevParent.id &&\n      // Check if the animation has loops\n      prevParent.iterationCount > 1 &&\n      // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n      prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime) {\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n      }\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n        // Rounding is necessary here to minimize floating point errors when working in seconds\n        const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);\n        prevSibling._changeDuration = updatedPrevChangeDuration;\n        prevSibling._currentTime = updatedPrevChangeDuration;\n        prevSibling._isOverlapped = 1;\n\n        // Override the previous tween if its new _changeDuration is lower than minValue\n        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough\n        if (updatedPrevChangeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separately\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // Handle additive tweens composition\n  } else if (tweenCompositionType === compositionTypes.blend) {\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n    let lookupTween = additiveTweenSiblings._head;\n    if (!lookupTween) {\n      lookupTween = {\n        ...tween\n      };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n  }\n  return tween;\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation} animation\n * @param  {String} [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween && tween._tweenType === tweenTypes.TRANSFORM && tween._prev && tween._prev._tweenType === tweenTypes.TRANSFORM) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {Renderable} [renderable]\n * @param  {String} [propertyName]\n */\nconst removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {\n  const parent = /** @type {Renderable|typeof engine} **/renderable ? renderable : engine;\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */child, propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        removeTargetsFromRenderable(targetsArray, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */parent.iterationDuration)) {\n      /** @type {Renderable} */parent.iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */parent, propertyName);\n  }\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */parent.cancel) /** @type {Renderable} */parent.cancel();\n  }\n};\nexport { composeTween, getTweenSiblings, overrideTween, removeTargetsFromRenderable, removeTweenSliblings };","map":{"version":3,"names":["minValue","compositionTypes","tweenTypes","forEachChildren","removeChild","isUnd","addChild","round","cloneArray","sanitizePropertyName","engine","addAdditiveAnimation","additive","lookups","_rep","WeakMap","_add","Map","getTweenSiblings","target","property","lookup","lookupMap","targetLookup","get","set","_head","_tail","addTweenSortMethod","p","c","_isOverridden","_absoluteStartTime","overrideTween","tween","_isOverlapped","_changeDuration","_currentTime","composeTween","siblings","tweenCompositionType","_composition","replace","tweenAbsStartTime","prevSibling","_prevRep","prevParent","parent","prevAbsEndTime","id","iterationCount","duration","iterationDuration","prevPrevSibling","absoluteUpdateStartTime","_delay","prevChangeStartTime","_startTime","prevTLOffset","_updateDuration","updatedPrevChangeDuration","pausePrevParentAnimation","t","prevParentTL","pausePrevParentTL","a","cancel","blend","additiveTweenSiblings","additiveAnimation","lookupTween","_numbers","_fromNumbers","_number","_next","_prev","toNumber","_toNumber","_fromNumber","_toNumbers","toNumbers","forEach","value","i","removeTweenSliblings","tweenComposition","none","tweenTarget","tweenProperty","replaceTweensLookup","replaceTargetProps","tweenReplaceSiblings","addTweensLookup","addTargetProps","animation","shouldClean","prop","delete","removeTargetsFromJSAnimation","targetsArray","propertyName","tweensMatchesTargets","includes","tweenName","tweenType","_tweenType","normalizePropName","TRANSFORM","_renderTransforms","removeTargetsFromRenderable","renderable","removeMatches","_hasChildren","child","childTLOffset","_offset","childDur"],"sources":["/Users/mukku/Desktop/Work and Education/Projects/zeronia.org/node_modules/animejs/dist/modules/animation/composition.js"],"sourcesContent":["/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { minValue, compositionTypes, tweenTypes } from '../core/consts.js';\nimport { forEachChildren, removeChild, isUnd, addChild, round, cloneArray } from '../core/helpers.js';\nimport { sanitizePropertyName } from '../core/styles.js';\nimport { engine } from '../engine/engine.js';\nimport { addAdditiveAnimation, additive } from './additive.js';\n\n/**\n * @import {\n *   TweenReplaceLookups,\n *   TweenAdditiveLookups,\n *   TweenPropertySiblings,\n *   Tween,\n *   Target,\n *   TargetsArray,\n *   Renderable,\n * } from '../types/index.js'\n *\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map(),\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null,\n  }\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n\n    const tweenAbsStartTime = tween._absoluteStartTime;\n\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n        // Check if the previous tween is from a different animation\n        tween.parent.id !== prevParent.id &&\n        // Check if the animation has loops\n        prevParent.iterationCount> 1 &&\n        // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime\n      ) {\n\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n\n      }\n\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n        // Rounding is necessary here to minimize floating point errors when working in seconds\n        const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);\n\n        prevSibling._changeDuration = updatedPrevChangeDuration;\n        prevSibling._currentTime = updatedPrevChangeDuration;\n        prevSibling._isOverlapped = 1;\n\n        // Override the previous tween if its new _changeDuration is lower than minValue\n        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough\n        if (updatedPrevChangeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separately\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n  // Handle additive tweens composition\n\n  } else if (tweenCompositionType === compositionTypes.blend) {\n\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n\n    let lookupTween = additiveTweenSiblings._head;\n\n    if (!lookupTween) {\n      lookupTween = { ...tween };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n\n  }\n\n  return tween;\n\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation} animation\n * @param  {String} [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween &&\n            tween._tweenType === tweenTypes.TRANSFORM &&\n            tween._prev &&\n            tween._prev._tweenType === tweenTypes.TRANSFORM\n        ) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {Renderable} [renderable]\n * @param  {String} [propertyName]\n */\nconst removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {\n  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        removeTargetsFromRenderable(targetsArray, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {\n      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromJSAnimation(\n      targetsArray,\n      /** @type {JSAnimation} */(parent),\n      propertyName\n    );\n  }\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();\n  }\n};\n\nexport { composeTween, getTweenSiblings, overrideTween, removeTargetsFromRenderable, removeTweenSliblings };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}